{"name":"BOTServer","tagline":"http://telegram.org Bot Platform webhooks server, for Rubyists","body":"# BOTServer\r\n[Telegram](http://Telegram.org) Bot Platform webhooks server, for Rubyists.\r\n\r\n## Telegram Bots Platform ?\r\nPlease read offical documentation:\r\n* [Telegram Bot Platform Revolution!](https://telegram.org/blog/bot-revolution) \r\n* [Bots: An introduction for developers](https://core.telegram.org/bots)\r\n* [Telegram Bot API](https://core.telegram.org/bots/api)\r\n\r\n## Why ?\r\n\r\n* First goal: \r\n  set-up a Ruby way to manage Telegram Bot API 'getUpdates' via HTTPS webhooks, a performance improvement in comparison with HTTPS long polling. So let consider this as an appendix of [telegram-bot-ruby](https://github.com/atipugin/telegram-bot-ruby) gem, Alexander Tipugin's excellent Telegram Bot APIs wrapper; to thank him for his work, I tried to solve issue #19: [setting up webhooks with telegram-bot-ruby ?](https://github.com/atipugin/telegram-bot-ruby/issues/19). BOTServer here is to close the open issue :)\r\n\r\n* Second goal:\r\n  receive https callbacks is probably more efficient than getting updates on a long polling connection, but the real need of webhooks is when you have many bots to manage at once. Let say **dozen, hundreds of bots**! In this scenario, it could pretty impossible to manage in a single host, so many long polling connections, because we have to maintain open too many HTTPS persistent connections for long polling mode. \r\n\r\nMore details about long polling vs webhooks in wiki document: [Telegram Bot Architecture(s)](https://github.com/solyaris/BOTServer/blob/master/wiki/architectures.md)\r\n\r\n```\r\n      +----+\r\n      | device                 +---------+\r\n      |    |     +-------+     |      device                   +-----+\r\n      |    |     |    device   |         |                  device   |\r\n      +--+-+     |       |     |         |   +-------------+   |     |\r\n         |       +---+---+     +----+----+   |             |   |     |\r\n         |           |              |     device           |   +--+--+\r\n         |           |              |        +------+------+      |\r\n         |           |              |               |             |\r\n+--------+-----------+--------------+---------------+-------------+------------------+\r\n| T E L E G R A M . O R G   N E T W O R K                                            |\r\n+--+----------------------------------------+-----+-------------------------------+--+\r\n   | Telegram Bot Webhooks API              |     | Telegram Bot Long Polling API |\r\n   +-+-+-+---------------------------+-+-+--+     +--+------------+--+------+-+---+\r\n     v v v                           ^ ^ ^           v            v         ^ ^\r\n     | | | HTTPS webhooks            https           | many HTTPS |         | |\r\n  +--| | |--+                        | | |           | persistent |         | |\r\n  |  | | |  +---------------+        | | |           | conn.      |         | |\r\n  |  | | +--> Bot 1         |--------+ | |           |            |         | |\r\n  |  | |    +---------------+          | |           v            v         ^ ^\r\n  |  | |    |                          | |           |            |         | |\r\n  |  | |    +---------------------+    | |           |            |         | |\r\n  |  | +----> Bot 2               |----+ |     +-----v------+     |         | |\r\n  |  |      +---------------------+      |     | Bot 1      |---------------+ |\r\n  |  |      |                            |     +------------+     |           |\r\n  |  |      +--------+                   |                        |           |\r\n  |  +------> Bot N  |-------------------+                        |           |\r\n  |         +--------+                                   +--------v-----+     |\r\n  |         |                                            | Bot N        |-----+\r\n  +---------+ Webhooks BOTServer                         +--------------+\r\n```\r\n\r\n## A lot of bots ?\r\n\r\nYou are maybe asking yourself, what the hell of application needs so many bots!? Let consider a sort of e-commerce marketplace, where your backend bot server must manage multiple bots, where each bot \"represent\" any shop, any service supplier, any merchant interface! \r\nConfused ? I reported some examples of bots usage in humans-to-humans ineternedaition, see: [Innovative Chatbot Services with Telegram](https://github.com/solyaris/BOTServer/blob/master/wiki/services.md). By example consider a \"Pizza maker in-store shop\" scenario, where a buyer do an online order chatting with a virtula shop bot, that helps buyer filling order and sending order to seller! So, for this \"marketplace\" it make sense to manage a multitude of bots (1 bot = 1 shop) with an efficient server architecture. For this specific business reason I created BOTServer: a sort of **webhooks handler microframework to serve \"a lot of bots\"**.\r\n\r\n### Nuts and bolts\r\n\r\nBOTServer provides some command line scripts to build the game. Just run `rake` from your project home: \r\n\r\n```\r\n$ rake\r\nrake app:new[token]        # create bot app template for given token\r\nrake certificate:new       # create certificate\r\nrake certificate:show      # show public certificate\r\nrake proxy:new             # show nginx proxy configuration for ssl\r\nrake rack:log              # show rack sever logfile: /your_home/BOTServer/log/thin.log\r\nrake rack:pid              # rack server pid\r\nrake rack:restart          # restart rack server\r\nrake rack:stop             # stop rack server\r\nrake server:check          # check server configuration: /your_home/BOTServer/config/server.yml\r\nrake server:show           # show server configuration: /your_home/BOTServer/config/server.yml\r\nrake tokens:check          # verify tokens, online querying Telegram Server\r\nrake tokens:show           # show tokens configuration file: /your_home/BOTServer/config/tokens.yml\r\nrake webhook:reset[token]  # Reset webhook for given token\r\nrake webhook:set[token]    # Set webhook for given token\r\n```\r\n\r\nIn next paragraph I'll show you step by step, explaining all in detail what commands are for. \r\n\r\nBOTServer run-time engine is very simple: it's a [rack](https://github.com/rack/rack) application (now implemented with [Sinatra](http://www.sinatrarb.com/), but I'll soon substitute it with flat **fast** rack app), that dispatch dinamically incoming token webhooks, calling update method of an instance of a pregenerated class, that define the bot. So, yes, I used a bit Ruby on Rails metaprogramming paradigma for the game. Here below the dispatcher (`rackup/sinatra.rb`) code extract:\r\n\r\n```Ruby\r\n# load bots in memory. return a lookup table\r\nset lookup: Loader.create_lookup(Config.tokens_config_file)\r\n\r\n# HTTPS POST webhook endpoint(s)\r\npost '/:token' do | token |\r\n\r\n  # retrieve name, method object pair from lookup table\r\n  bot = settings.lookup[token.to_sym]\r\n  \r\n  unless bot.nil?\r\n    request.body.rewind\r\n    body = request.body.read\r\n    data = MultiJson.load(body)\r\n    update = Telegram::Bot::Types::Update.new(data)\r\n\r\n    # TRICKY:  object method run-time execution\r\n    bot[:method].call(update)\r\n  end\r\nend\r\n```\r\n\r\n## Assembly instructions in 7 steps\r\n\r\nBOTServer is nothing else than a sequential devops tasks and a runt-time webhooks dispatcher. I list here and I'll explain in deep in next paragraps: \r\n\r\n1. Install a web/proxy server, Ruby project stuff\r\n2. Create (self-signed) Certificate\r\n3. Get your Telegram Bot token(s)\r\n4. Set-up configuration files\r\n5. Set \"Webhooks mode\" for each token \r\n6. Generate template for each bot\r\n7. Deploy and run BOTServer\r\n\r\n\r\n### Step 1. Installation\r\n\r\n#### Install your preferred proxy-server \r\nThis is a pro-Soviet project (I'm joking) and we love Igor Sysoev's [NGINX](http://nginx.org/) web server creature!:-). Jokes a part, using a front end server is not mandatory. By example my preferred rack server, [Thin](http://code.macournoyer.com/thin/) is able to manage HTTPS and certificates, but there is a security concern here: when receiving webhooks, you expose your own server to possible attacks, and it's better to do not expose to crazy internet your preferred Ruby rack server (Thin, Puma, whatever).\r\n\r\nNGINX is a great fast and robust front-end firewall and load balancer. Last but not least, NGINX know how to manage SSL certificates and all digital certificates' cross-validations. \r\n\r\nNGINX installation depends on your OS. Please refer to NGINX website for download and installation info. \r\n\r\nSee architectural overview here behind: NGINX act as a SSL manager, proxy and load balancer in front of one or many rack servers (workers).\r\n\r\n```\r\n+-----------------------------------------------------------------------------------+\r\n| TELEGRAM NETWORK                                                                  |\r\n+-----------------------------------------------------------------------------------+\r\n   v v v v                                                                   ^ ^ ^\r\n   | | | |    NGINX                                                          | | |\r\n   | | | |    SSL/HTTPS                                                      | | | \r\n   | | | |    front-end/balancer                                             | | |\r\n   | | | |    +------+            Hooks Rack Server (Thin worker 1)          | | |\r\n   | | | |    |      |            +------+                                   | | |\r\n   | | | | w  |      |            |      |     +---------------+ HTTPS send  | | |\r\n   | | | | e  |      |            |      ------> App 1         |-------------+ | |\r\n   | | | | b  |      |            |      |     +---------------+               | |\r\n   | | | | h  |      |            |      |                                     | |\r\n   | | | | o  |      |            |      |     +---------------+ HTTPS send    | |\r\n   | | | | o  |      ------------>| W1   -------> App 2        |---------------+ |\r\n   | | | | k  |      |            |      |     +---------------+                 |\r\n   | | | | s  |      |            |      |                                       |\r\n   | | | +--->|      |            |      |     +---------------+  HTTPS send     |    \r\n   | | +----->|      |            |      ------> App N         |-----------------+\r\n   | +------->|      |            |      |     +---------------+\r\n   |     ---->|      |            +------+\r\n   |     ---->|      |        \r\n   |     ---->|      ------------> W2\r\n   |     ---->|      ------------> W3\r\n   |     ---->|      ------------> W4\r\n   |     ---->|      |        \r\n   |     ---->|      |             Hooks Rack Server (Thin worker 5)  \r\n   +--------->|      |            +------+\r\n              |      |            |      |                     \r\n              |      |            |      ------>               \r\n              |      ------------>|W5    ------>                \r\n              |      |            |      ------>               \r\n              |      |            +------+\r\n              +------+     \r\n```\r\n\r\nBTW, to configure Thin workers behind NGINX, see old interesting Marc-André Cournoyer's (Thin creator) post:[Get intimate with your load balancer tonight!](https://macournoyer.wordpress.com/2008/01/26/get-intimate-with-your-load-balancer-tonight/) \r\n\r\n\r\n#### Install this project code and bundle all Ruby stuff\r\n\r\n```bash\r\n$ git clone https://github.com/solyaris/BOTServer.git\r\n$ cd BOTServer && bundle install\r\n```\r\n\r\n\r\n### Step 2. Create (self-signed) Certificate\r\n\r\nI prepared a rake command to just show on command line terminal an openssl command to build-up secret an publick key. Please copy/paste to generate your self-signed certificate, modifying the shown command with your personal data:\r\n\r\n```bash\r\n$ rake certificate:new\r\n```\r\n\r\n### Step 3. Get your Telegram Bot token(s)\r\n\r\nYou have to chat with [Telegram Bot Father](https://core.telegram.org/bots#botfather), to create each of your bot!\r\nAfterward, take your secret tokens on your secret files.\r\n\r\n\r\n### Step 4. Set-up configuration files\r\n\r\nConfigure and check tokens.yml and server.yml\r\n\r\n```bash\r\n$ vi config/tokens.yml\r\n$ rake tokens:check\r\n$ vi config/server.yml\r\n$ rake server:check\r\n```\r\n\r\n#### server.yml example \r\n\r\n```yaml\r\nhost: your_domain.com port: 8443\r\n\r\ncertificate_file_key: ssl/PRIVATE.key\r\ncertificate_file_pem: ssl/PUBLIC.pem\r\n```\r\n\r\n#### tokens.yml example \r\n\r\n```yaml\r\n- token: 070743004:yuSJJdB5L354Zq41iGIggSdYGJ1IhVh8XSA\r\n  description: Il negozio della memoria dimenticata\r\n \r\n- token: 998001334:zAFo4dBdd3ZZtqgKiGdPqkkYGJ1ppVW8pUZ\r\n  description: Dolcetto o Scherzetto? \r\n \r\n- token: 007863333:NNkdudnNhdhGGo775SjYTurr45hh00W99AB\r\n  description: Rosticceria Sacco, la migliore di Genova\r\n \r\n- token: 565000782:KKKKsssNsshsjHT75SjYTu56klsh00W99AB\r\n  description: Franco Califfano Fruttivendolo\r\n \r\n- token: 127652228:JjfssGj7GSlSH0075SjYTu5jj845ssWKXXZ\r\n  description: Spaghetteria Nadia Parodi \r\n```\r\n\r\n#### configure NGINX to manage your digital certificate\r\n\r\nTo show nginx proxy configuration for ssl, you can generate a template configuration.\r\nAfterward copy/paste/modify and update your NGINX configuration file.\r\n\r\n```bash\r\nrake proxy:new\r\n```\r\n\r\n### Step 5. Set Webhooks      \r\n\r\nSet webhook for each token\r\n\r\n```bash\r\n$ rake webhook:set[YOUR_TOKEN_1]\r\n$ rake webhook:set[YOUR_TOKEN_2]\r\n$ rake webhook:set[YOUR_TOKEN_3]\r\n$ rake webhook:set[YOUR_TOKEN_N]\r\n```\r\nBTW, if you want to reset a webhook, to go back with long polling (EXCLUSIVE) mode, for example for bot associated with token YOUR_TOKEN_N, just run command: \r\n```bash\r\n$ rake webhook:reset[YOUR_TOKEN_N]\r\n```\r\n\r\n### Step 6. Generate template for each of your application bots\r\n\r\ncreate bot app template for each token:\r\n```bash\r\n$ rake app:new[YOUR_TOKEN_1]\r\n$ rake app:new[YOUR_TOKEN_2]\r\n$ rake app:new[YOUR_TOKEN_3]\r\n$ rake app:new[YOUR_TOKEN_4]\r\n```\r\n\r\nMy idea here, is to generate an app template, to be filled with your own logic. The generated app implement just an echo-server trivial logic. Of course you have to link-up here, in the update method your real bot LOGIC!\r\n\r\n\r\n```Ruby\r\n#\r\n# file: yourappexample.rb \r\n#\r\nrequire 'telegram/bot'\r\n\r\nclass Yourappexamplebot \r\n  attr_reader :token, :client\r\n\r\n  def initialize\r\n    @token = 'YOUR_APP_EXAMPLE_TOKEN'\r\n    @client = Telegram::Bot::Client.new(@token)\r\n  end\r\n\r\n  #\r\n  # message(s) updates from telegram server.\r\n  # put ALL your Telegram Bot logic here.\r\n  #\r\n  def update(data)\r\n    update_id = data.update_id\r\n    message = data.message\r\n    message_id = message.message_id \r\n    \r\n    #\r\n    # #######################\r\n    # PUT HERE YOUR BOT LOGIC\r\n    # #######################\r\n    #    \r\n\r\n    # echo-server, just for test purpose\r\n    case message.text\r\n    when /.+/ \r\n      text = \"#{message.from.first_name}:#{message.text}\"\r\n      chat_id = message.chat.id\r\n\r\n      # send echo to user \r\n      client.api.send_message(chat_id: chat_id, text: text)\r\n      puts \"#{update_id}:#{message_id}:#{text}\"\r\n    end  \r\n  end\r\n\r\n\r\n  alias get_update update\r\nend\r\n```\r\n\r\n\r\n### Step 7. Deploy and Run\r\n\r\n* Start web server\r\n* Start rack server\r\n* Monit incoming webhooks\r\n\r\n```bash\r\n$ service nginx restart\r\n$ rake rack:restart\r\n$ rake rack:log\r\n```\r\n\r\n## Wiki\r\n\r\n* Long polling vs webhooks \r\n [Telegram Bot: Long polling vs Webhooks](https://github.com/solyaris/BOTServer/blob/master/wiki/architectures.md)\r\n* Telegram networks concepts and services\r\n  p2p chats, groups, channels and ideas about some \"innovative\" Telegram-based SERVICES, integrating humans an chatbots (machine learning enabled software creatures): [Innovative Chatbot Services with Telegram](https://github.com/solyaris/BOTServer/blob/master/wiki/services.md). Very draft doc.\r\n\r\n\r\n## To do\r\n\r\n1. Substitute the Sinatra rack handler with pure rack implementation\r\n2. Add Puma as rack server\r\n3. Update server.yml after cerrtificate generation\r\n4. Make a BOTServer gem \r\n5. Possibly separate the handler kernel from any Telegram bot logic\r\n\r\n\r\n## Release notes\r\n\r\n### v.0.0.1\r\nFirst release: 28 November 2015\r\n\r\n\r\n## License \r\n\r\nBOTServer is released under the [MIT License](http://www.opensource.org/licenses/mit-license).\r\n\r\n\r\n## Thanks to\r\n\r\n* Alexander Tipugin for [telegram-bot-ruby](https://github.com/atipugin/telegram-bot-ruby) gem and time in e-mail converstaions.\r\n* Paolo Montrasio [connettiva.eu](http://www.connettiva.eu/index-en.html) for his insistence to use NGINX. stop :-)\r\n* Marc-André Cournoyer's for [Thin](http://code.macournoyer.com/thin/) rack server.\r\n\r\n## Contacts\r\n\r\n* **If you feel useful this work, please star the project :-)**\r\nPlease feel free to open an issue here in github, just to share suggestions/notes and of course bugs (I'm specilized on making them!). Maybe you can put in the issue title a keyword like: [note], [thanks], [bug], [feature request], [issue], etc. Any comment or criticis are anyway welcome.\r\n* blog: [@solyarisoftware](http://www.twitter.com/solyarisoftware), I share here my thoughts about Ruby language, instant messaging, chat bots, natural language processing, mobile e-payment and e-commerce systems, politcs and socioeconomic nightmares, in Italy.\r\n* mail: [giorgio.robino@gmail.com](mailto:giorgio.robino@gmail.com)\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}